# move语言笔记

## 变量

一个有效的变量名可以包含下划线 `_`，小写字母 `a` 到 `z` ，大写字母 `A` 到 `Z`， 和数字 `0` 到 `9` 。变量名必须以下划线`_`或者以小写字母`a`到`z`开头。它们 *不可以* 用大写字母开头

### 局部变量

#### 声明

[声明局部变量 (Declaring Local Variables)](https://move-dao.github.io/move-book-zh/variables.html#声明局部变量-declaring-local-variables)

变量必须在使用前赋值

#### 类型标注

局部变量的类型几乎总是可以通过 Move 的类型系统推断出来。 但是，Move 允许显式标注类型，这对可读性、清晰性或可调试性很有用。 添加类型标注的语法如下

```
let x: T = e; // "变量 x 的类型 T 被定义为表达式 e"
```

值得注意的是，类型标注必须总是位于**变量右边**的模式：

```
let (x: &u64, y: &mut u64) = (&0, &mut 1); // 错误! 正确写法是 let (x, y): ... =
```

##### 何时需要标注类型

在某些情况下，如果类型系统无法推断类型，则需要局部类型标注。这常常发生于无法推断某个泛型(generic type)的类型参数时。比如：

```
let _v1 = vector::empty(); // 错误!
//        ^^^^^^^^^^^^^^^ 无法推断它的类型。 请加上注解
let v2: vector<u64> = vector::empty(); // 正确
```

在极少数情况下，Move的类型系统并不能推断出一段发散式代码(divergent code)的类型(后面所有代码无法访问)。在Move语言中，`return` 和 [`abort`](https://move-dao.github.io/move-book-zh/abort-and-assert.html)都属于表达式，它们可以返回任何类型。如果一段 [`loop`](https://move-dao.github.io/move-book-zh/loops.html) 有 `break` 语句，那么它的返回类型是`()`, 然而如果它不包含`break`语句，它的返回类型可以是任何类型。如果这些类型无法推断，类型标注是必须的。比如

```
let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
```

### 元组式的批量声明

`let` 可以使用元组一次引入多个局部变量。在括号里面声明的局部变量会被初始化为元组中的对应值。

```
let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
```

不能在单个 `let` 中声明多个具有相同名称的局部变量。

```
let(x,x)=(0,0)
```

### 结构体中的多个变量声明

`let` 也可以在解构(或匹配)结构时一次引入多个局部变量。在这种形式中，`let` 创建了一组局部变量，这些变量被初始化为结构中的字段的值。语法如下所示：

```
struct T{f1:u64,f2:u64}
```

```
let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
```

​    

```
address 0x42 {
    module example {
        struct X { f: u64 }
        struct Y { x1: X, x2: X }// X表示类型，如u

        fun new_x(): X {  // :X表示返回值，// X { f: 1 }表示返回一个结构体，里面放一个1
            X { f: 1 }
        }

        fun example() {
            let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };
            assert!(f + x2.f == 2, 42);

            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };
            assert!(f1 + f2 == 2, 42);
        }
    }
}

```

结构体的字段可以起到双重作用：识别要绑定的字段 *和* 命名变量。这有时被称为双关语。

```
let X { f } = e;
```

等价于

```
let X { f: f } = e;
```

通用的let语法

```
    let (x, y): (u64, u64) = (0, 1);
//       ^                           局部变量
//       ^                           模式
//          ^                        局部变量
//          ^                        模式
//          ^                        模式列表
//       ^^^^                        模式列表
//      ^^^^^^                       模式或列表
//            ^^^^^^^^^^^^           类型注解
//                         ^^^^^^^^  初始化的值
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-绑定

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    结构类型
//            ^                                字段
//            ^                                字段绑定
//               ^                             字段
//                  ^                          局部变量
//                  ^                          模式
//               ^^^^                          字段绑定
//            ^^^^^^^                          字段绑定列表
//      ^^^^^^^^^^^^^^^                        模式
//      ^^^^^^^^^^^^^^^                        模式或列表
//                      ^^^^^^^^^^^^^^^^^^^^   初始化的值
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-绑定

```

### 更改

在引入一个局部变量后(使用`let`或是用作一个函数参数(function parameter))，局部(变量)可以通过赋值进行修改：

```
x = e
```

不同于 `let` 的绑定，赋值属于表达式。在一些编程语言中，赋值表达式会返回被赋予的值，但是在move语言中，任何赋值返回的类型永远都是`()`。

```
(x = e: ())
```

实际应用中，赋值属于表达式意味着使用它们时不用添加额外表达块(expression block)的括号。(`{`...`}`)

值得注意的是一个局部变量只能有一种类型，所以局部变量不能在赋值之间(多次赋值)改变类型。

### 通过引用进行变更

除了通过赋值直接修改局部变量外，还可以通过可变引用 `&mut` 的方式修改局部变量。

```
let x = 0;
let r = &mut x;
*r = 1;
assert!(x == 1, 42)
}
```

这在以下情况下特别有用:

(1) 您想根据某些条件修改不同的变量。

```
let x = 0;
let y = 1;
let r = if (cond) &mut x else &mut y;
*r = *r + 1;
```

(2) 您想要另一个函数来修改您的局部(变量)值。

```
let x = 0;
modify_ref(&mut x);
```

### 作用域

使用 `let` 声明的任何局部变量都可用于任何后续表达式，*在该范围内*。作用域用表达式块(expression blocks)声明，`{`...`}`。

局部变量不能在声明的作用域之外使用。

但是，来自作用域外部的部变量 *可以* 在嵌套作用域中使用。

局部变量可以在允许访问的任何作用域内进行变更(mutation)。与进行变更的作用域无关，这种变更会跟随局部变量的生命周期。

### 表达式块

表达式块是由分号 (`;`) 分隔的一系列语句。结果值为表达式块是块中最后一个表达式的值。

```
{ let x = 1; let y = 1; x + y }//这个表达式块的结果值是x+y（2）
```

在此示例中, 此区块的结果是 `x + y`.

语句可以是 `let` 声明或表达式。请记住赋值(`x = e`)是 `()` 类型的表达式。

函数调用是 `()` 类型的另一种常见表达方式。修改数据的函数调用通常被用作语句表达

```
{ let v = vector::empty(); vector::push_back(&mut v, 1); v }
```

这不仅限于 `()` 类型——任何表达式都可以用作序列中的语句！

如果块中不存在最终表达式---也就是说，如果有一个尾随分号`;`，有一个隐含的 unit `()` 值。同样，如果表达式块为空，则存在隐式 unit `()` 值。

```
// 两者是相同的
{ x = x + 1; 1 / x; }
{ x = x + 1; 1 / x; () }
```

表达式块本身就是一个表达式，可以在任何使用表达式的地方使用。 (注意：函数体也是表达式块，但函数体不能被另一个表达式替换。)

如果一个 `let` 引入了一个已经在作用域内的同名局部变量，那么之前的变量不能继续在此作用域的其余部分访问。这称为 *遮蔽* ( *shadowing* )。

### 遮蔽

当局部变量被遮蔽时，它不需要保留与以前相同的类型。

一个局部变量被遮蔽后，存储在局部变量的值仍然存在，但将变得不再可访问。对于没有[`drop` 能力](https://move-dao.github.io/move-book-zh/abilities.html)的类型的值，请记住这一点很重要，因为值的所有权必须在函数结束时转移。

当局部变量在作用域内被遮蔽时，该遮蔽作用仅保留在该作用域内。一旦该作用域结束，遮蔽就会自动消失。注意，局部变量在被遮蔽时可以更改类型。

### move copy

`move` 从局部变量中取走值 *而不是* 复制数据。发生`移动`后，局部变量会不可用

```
let x = 1;
let y = move x + 1;
//      ------ 局部变量被移动到这里了
let z = move x + 2; // 错误!
//      ^^^^^^ 不合规范的'x'使用方式
y + z

```

使用 `copy`，本地变量可以多次使用

```
let x = 0;
let y = copy x + 1;
let z = copy x + 2;
```

任何具有copy能力的值都可以通过这种方式复制

```
let s = b"hello";
let foo = Foo { f: 0 };//可能这种类似的声明，是移动
let coin = Coin { value: 0 };

let s2 = s; // 移动
let foo2 = foo; // 移动
let coin2 = coin; // 移动

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &x;
let coin_ref = &mut coin2;

let x2 = x; // 复制
let b2 = b; // 复制
let addr2 = @0x42; // 复制
let x_ref2 = x_ref; // 复制
let coin_ref2 = coin_ref; // 复制

```

